# База знаний проекта

> **ВАЖНО!** Актуальная конфигурация системы (серверы, порты, модели) находится в файле [docs/SYSTEM_CONFIG.md](docs/SYSTEM_CONFIG.md). При внесении любых изменений в настройки соединений, адресов или портов **ОБЯЗАТЕЛЬНО** обновляйте этот файл!

## Принципы работы с конфигурацией

1. **Централизованная конфигурация** - Все настройки портов, адресов серверов и моделей хранятся в едином документе `docs/SYSTEM_CONFIG.md`
2. **Проверка перед изменением** - Перед внесением изменений в настройки соединений обязательно сверяйтесь с актуальной конфигурацией
3. **Обновление документации** - После внесения изменений немедленно обновляйте документацию, включая дату и причину изменений
4. **Валидация изменений** - После внесения изменений проверяйте работоспособность всех компонентов системы

## Проблемы и их решения

### Блокировка хранилища Qdrant

**Проблема:**
При одновременном запуске нескольких процессов, использующих Qdrant в локальном режиме (API сервер и Telegram-бот), может возникать ошибка:
```
Storage folder data/memory/long_term/qdrant is already accessed by another instance of Qdrant client. If you require concurrent access, use Qdrant server instead.
```

**Решение:**
1. **Краткосрочное решение:** Удаление файла блокировки `.lock` из директории Qdrant и перезапуск сервисов:
   ```bash
   rm -f data/memory/long_term/qdrant/.lock
   ```

2. **Долгосрочное решение:** Модификация `memory_manager.py` для обработки ошибок блокировки:
   - Добавлена автоматическая очистка файлов блокировки
   - Добавлен механизм отказоустойчивости с переключением на in-memory режим при ошибках

3. **Рекомендуемое решение:** Использование Qdrant в серверном режиме вместо локального клиента:
   - Установить Qdrant Server (через Docker или pip)
   - Изменить конфигурацию подключения на использование серверного API
   - Подробная документация: `docs/qdrant_server_setup.md`

**Причины проблемы:**
- Локальный режим Qdrant не поддерживает конкурентный доступ
- Несколько процессов пытаются получить доступ к одному хранилищу
- Файл блокировки остается после аварийного завершения процесса 

### Проблема с отсутствующим методом add_ai_message

**Проблема:**
При взаимодействии через LangChain Router может возникать ошибка:
```
'MemoryManager' object has no attribute 'add_ai_message'
```

**Причина:**
В модуле `multi_agent_system/memory/conversation_memory.py` класс `MemoryManager` из `src/core/memory_system/memory_manager.py` переименован в `ConversationMemoryManager` через импорт-алиас, но в `langchain_router.py` используется метод `add_ai_message`, который отсутствует в исходном классе `MemoryManager`.

**Решение:**
Добавлен метод-алиас `add_ai_message` в класс `MemoryManager`, который вызывает существующий метод `add_assistant_message`, но с изменённым именем параметра (`agent_name` вместо `agent_id`) для совместимости с интерфейсом LangChain Router.

```python
def add_ai_message(
    self,
    user_id: str,
    content: str,
    agent_name: Optional[str] = None,
    metadata: Optional[Dict[str, Any]] = None
) -> None:
    """
    Алиас для метода add_assistant_message для совместимости с интерфейсом langchain_router.
    """
    return self.add_assistant_message(
        user_id=user_id,
        content=content,
        agent_id=agent_name,  # Пересылаем agent_name как agent_id
        metadata=metadata
    )
```

**Примечание:**
В будущем рекомендуется либо стандартизировать интерфейсы между различными компонентами системы, либо использовать адаптеры для преобразования интерфейсов вместо прямых вызовов методов с разными именами. 

### Проблема с запуском Telegram бота

**Проблема:**
Telegram бот не отвечал на команды пользователей. В логах обнаруживалась ошибка:
```
cannot import name 'main' from 'telegram_bot.telegram_bot'
```

**Причина:**
В файле `run_telegram_bot.py` была попытка импортировать функцию `main` из модуля `telegram_bot.telegram_bot`, но такой функции в этом модуле не существовало. В модуле `telegram_bot.telegram_bot` определена функция `main()`, но в файле `telegram_bot/__init__.py` экспортируется только функция `create_application`.

**Решение:**
Модифицирован файл `run_telegram_bot.py` для корректного импорта:
```python
# Было (некорректный импорт)
from telegram_bot.telegram_bot import main
# Затем вызов:
main()

# Стало (корректный импорт и использование)
from telegram_bot import create_application
from telegram_bot.config import config

# Создаем и запускаем приложение
application = asyncio.run(create_application(config))
application.run_polling()
```

**Результат:**
После исправления бот успешно запускается и отвечает на команды пользователей, корректно взаимодействуя с Mistral API, размещенной на сервере по адресу 139.59.241.176:8000.

**Рекомендации:**
1. При модификации интерфейсов модулей необходимо обновлять все места вызова этих интерфейсов
2. Следует согласовывать экспортируемые функции и классы в файлах `__init__.py` с их фактическим использованием
3. При возникновении ошибок импорта рекомендуется анализировать не только фактическое наличие функций в модулях, но и правильность их экспорта 

### Проблема с форматом запросов к Mistral API

**Проблема:**
При отправке запросов к Mistral API возникала ошибка 500 Internal Server Error:
```
Ошибка на сервере: 500, {"detail":""}
```

**Причина:**
1. Неправильное имя модели в конфигурации (использовалось "mistral-small" вместо фактически доступной модели)
2. Несоответствие конфигурации моделей с реально доступными на сервере

**Решение:**
1. Обновлен список доступных моделей через запрос к `/v1/models`:
```bash
curl -X GET http://139.59.241.176:8000/v1/models
```

2. Изменена конфигурация в `mistral_adapter.py`:
```python
MISTRAL_MODELS = {
    "TheBloke/Mistral-7B-Instruct-v0.3-GPTQ": {
        "max_tokens": 8000,
        "description": "Mistral 7B Instruct v0.3 GPTQ",
        "recommended_temperature": 0.7,
        "recommended_top_p": 0.9,
    }
}
```

3. Обновлено значение модели по умолчанию:
```python
model_name: str = "TheBloke/Mistral-7B-Instruct-v0.3-GPTQ"
```

**Результат:**
- Бот успешно подключается к Mistral API
- Запросы обрабатываются корректно
- Система использует актуальную модель, доступную на сервере

**Рекомендации:**
1. Перед настройкой адаптера всегда проверять доступные модели через API эндпоинт `/v1/models`
2. Использовать точные идентификаторы моделей, предоставляемые сервером
3. Регулярно проверять доступность и актуальность используемых моделей
4. Реализовать автоматическое обновление списка доступных моделей при инициализации адаптера 

### Проблема с несоответствием портов Mistral API

**Проблема:**
Телеграм-бот не отвечал на сообщения пользователей. В логах обнаруживалась ошибка:
```
Ошибка сервера Mistral (попытка 3/4): Ошибка на сервере: 500, {"detail":""}
```

**Причина:**
Несоответствие между фактическим портом, на котором работает сервер llama.cpp (8080), и портом, к которому пытался подключиться бот (8000). 

При этом скрипт мониторинга API показывал, что сервер доступен по адресу http://139.59.241.176:8000 через health endpoint (возвращал статус 200), но при попытке выполнения запросов генерации текста возникала ошибка 500.

**Решение:**
1. Выполнена проверка конфигурации сервера llama.cpp с помощью команды:
```bash
ssh root@139.59.241.176 "systemctl status llama-server.service" 
```
которая показала, что сервер запущен на порту 8080:
```
./llama-server -m /opt/models/mistral/Mistral-7B-Instruct-v0.3.Q4_K_M.gguf --port 8080 --host 0.0.0.0
```

2. Обновлены настройки подключения к API во всех конфигурационных файлах:
- `telegram_bot/config.py`: MISTRAL_API_URL изменен с `http://139.59.241.176:8000` на `http://139.59.241.176:8080`
- `src/model_service/model_adapter/mistral_adapter.py`: base_url по умолчанию изменен с порта 8000 на 8080
- `telegram_bot/model_service_client.py`: base_url изменен с порта 8000 на 8080 
- `src/utils/monitoring_script.py`: api_url изменен с порта 8000 на 8080

3. Перезапущены телеграм-бот и скрипт мониторинга с новыми настройками.

**Результат:**
- Бот успешно подключается к Mistral API и отвечает на сообщения пользователей
- Мониторинг API показывает стабильную доступность сервера
- Исчезли ошибки 500 при обработке запросов

**Рекомендации:**
1. При настройке многокомпонентной системы необходимо тщательно согласовывать порты и адреса между всеми компонентами
2. Рекомендуется использовать централизованную конфигурацию для настроек подключения, чтобы избежать рассинхронизации
3. Реализовать автоматическую проверку доступности API не только через health endpoint, но и через тестовый запрос генерации
4. Добавить в скрипт мониторинга проверку соответствия конфигурации с реальными настройками сервера

### Внедрение централизованной конфигурации

**Проблема:**
В системе регулярно возникали проблемы из-за несоответствия настроек между различными компонентами, особенно при изменении портов и адресов серверов.

**Причина:**
Отсутствие единого источника правды для конфигурационных параметров системы. Настройки портов, адресов серверов и моделей были разбросаны по разным файлам без централизованного контроля.

**Решение:**
1. Создан файл `docs/SYSTEM_CONFIG.md` с централизованной конфигурацией системы:
   - Перечислены все серверы и порты
   - Описаны эндпоинты API и их назначение
   - Указаны используемые модели и их параметры
   - Задокументированы команды запуска сервисов
   - Добавлена таблица истории изменений конфигурации

2. Добавлены ссылки на централизованную конфигурацию в ключевые документы:
   - README.md
   - ARCHITECTURE.md
   - KNOWLEDGE_BASE.md

3. Обновлен файл `.env.example` с актуальными настройками:
   - Исправлены URL и порты API
   - Добавлены комментарии по рабочим портам
   - Обновлены настройки модели

4. Разработан инструмент для автоматической валидации конфигурации:
   - `src/utils/config_validator.py` для проверки настроек
   - `scripts/start_bot_with_validation.sh` для запуска бота с предварительной валидацией

**Результат:**
- Создан единый источник правды для настроек системы
- Добавлены инструменты для автоматической проверки настроек
- Реализована защита от запуска с неправильной конфигурацией
- Улучшена документация системы

**Рекомендации:**
1. Перед внесением изменений в конфигурацию всегда сверяться с `docs/SYSTEM_CONFIG.md`
2. При изменении портов или адресов обязательно обновлять централизованную документацию
3. Перед запуском системы использовать валидатор конфигурации
4. Регулярно проверять соответствие настроек компонентов централизованной конфигурации
